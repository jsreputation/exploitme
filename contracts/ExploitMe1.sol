//Explain how someone could deposit more than 1 eth per block
//- Find a reentrancy vulnerability and send us a sample contract that exploits it
//- Optimise the `receive` function so that it is at least 20% cheaper and send a sample contract showing how the optimisation is done
// Is it possible for a miner to manipulate the block.number in order to allow more than 1 eth deposited in the same block?
// Or can you force a reentrancy on refundValue sent if more than the maxDeposit has been sent in the fallback function?



//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.11;

import "hardhat/console.sol";

contract ExploitMe1 {
    uint256 immutable DEPOSIT_LIMIT_PER_BLOCK = 1 ether;

    struct UserDeposit {
        uint256 balance;
        uint256 blockDeposited;
    }
    mapping(address => UserDeposit) public deposits;
    uint256 inBlockPrev;

    constructor() public {}

    receive() external payable {
        require(msg.value <= DEPOSIT_LIMIT_PER_BLOCK, "1 ETH ONLY");

        UserDeposit storage prev = deposits[tx.origin];

        console.log("\tExploitMe: balance: ", prev.balance);

        if(prev.blockDeposited != block.number) inBlockPrev = 0;
        uint256 maxDeposit = DEPOSIT_LIMIT_PER_BLOCK - inBlockPrev;

        console.log("\tinBlockPrev ========== ", inBlockPrev);
        console.log("\tExploitMe: blockNumber, maxDeposit, msg.value: ", block.number, maxDeposit, msg.value);

        uint256 refundValue;
        if (msg.value > maxDeposit) {
            // refund user if they are above the max deposit allowed
            refundValue = msg.value - maxDeposit;

            console.log("\tExploitMe: ExploitMe1 refunding...ETH.", refundValue);
            (bool success, ) = msg.sender.call{value: refundValue}("");
            require(success, "ETH SEND FAILED");

            prev.balance -= refundValue;
        }

        prev.balance += msg.value;
        prev.blockDeposited = block.number;

        inBlockPrev += (msg.value - refundValue);
    }

    function withdraw(uint256 amount) external {
        UserDeposit storage prev = deposits[tx.origin];
        require(prev.balance >= amount, "Insufficient balance");

        prev.balance -= amount;

        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "ETH SEND FAILED");
    }
}
